C51 COMPILER V9.60.7.0   MAIN                                                              07/24/2023 09:28:48 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\user\main.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\HAEDWARE\soft_ti
                    -mer;..\HAEDWARE\uart_Ringbuf) DEBUG OBJECTEXTEND PRINT(.\Listings\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "main.h"
   2          /***************************************************************************************
   3            * @ÊµÏÖÐ§¹û   ½×¶ÎÈý
   4          ¶¨Ê±Æ÷0£º 1ms
   5          ¶¨Ê±Æ÷1:  25ms
   6          
   7          ADCÍ¨µÀ£º
   8          AN0 - P00
   9          AN2 - P02
  10          AN4 - P04
  11          AN6 - P06
  12          
  13          ´®¿Ú£º
  14          RXD - P21
  15          TXD - P03
  16          
  17          PWM:
  18          PWM0  - P20 P22 P23 P24 P25 P26 P27
  19          
  20          Ö¸¶¨²¨ÐÎ:
  21          P01 P05 P07
  22          ***************************************************************************************/
  23          void main(void)
  24          {
  25   1          SystemInit();
  26   1          RingBuff_Init(&ringBuff);
  27   1      
  28   1          while (1)
  29   1          {
  30   2              WDTC |= 0x10;  // Çå¹·
  31   2      
  32   2              if (Uart1_rec.guc_Uartflag)
  33   2              {
  34   3                  memcpy(guc_Uartbuf_p, 0, UART1BUFLEN);
  35   3                  // ¹¦ÄÜÑ¡Ôñ
  36   3                  if (Uart1_rec.guc_Uartbuf_a[0] > 0 && Uart1_rec.guc_Uartbuf_a[0] < 6)
  37   3                  {
  38   4                      poll_task(Uart1_rec.guc_Uartbuf_a[0]);
  39   4                  }
  40   3                  else
  41   3                  {
  42   4                      sprintf(guc_Uartbuf_p,"Ã»ÓÐ¸ÃÃüÁî£¡\r\n");
  43   4                  }
  44   3                  
  45   3                  // Çå¿Õ´®¿Ú½ÓÊÕ»º´æ
  46   3                  memcpy(Uart1_rec.guc_Uartbuf_a, 0, 20);
  47   3      
  48   3                  // ½ÓÊÕÏÂÒ»Ö¡Êý¾Ý
  49   3                  Uart1_rec.guc_Uartflag = 0;
  50   3                  
  51   3                  
  52   3                  WriteStr_RingBuff(guc_Uartbuf_p,&ringBuff);
  53   3                  
  54   3                  
C51 COMPILER V9.60.7.0   MAIN                                                              07/24/2023 09:28:48 PAGE 2   

  55   3                  /* ´®¿Ú·¢ËÍ */
  56   3                  if (ringBuff.FlagByte & 0x01) 
  57   3                  {
  58   4                      ringBuff.FlagByte &= ~0x01;  //´®¿ÚÃ¦
  59   4                      TI = 1;
  60   4                  }
  61   3              }
  62   2          }
  63   1      }
  64          
  65          /***************************************************************************************
  66           * @ËµÃ÷        ³õÊ¼»¯ËùÓÐÍâÉè
  67           *      @²ÎÊý     ÎÞ
  68           * @·µ»ØÖµ ÎÞ
  69           * @×¢            ÎÞ
  70           ***************************************************************************************/
  71          
  72          void SystemInit(void)
  73          {
  74   1          /************************************ ÏµÍ³³õÊ¼»¯ ****************************************/
  75   1          //    WDTCCR = 0x00;                                                //¹Ø±Õ¿´ÃÅ¹·
  76   1          CLKSWR = 0x51;  // Ñ¡ÔñÄÚ²¿¸ßÆµRCÎªÏµÍ³Ê±ÖÓ£¬ÄÚ²¿¸ßÆµRC 2·ÖÆµ£¬Fosc=16MHz
  77   1          CLKDIV = 0x01;  // Fosc 1·ÖÆµµÃµ½Fcpu£¬Fcpu=16MHz
  78   1      
  79   1          /********************************** ´®¿Ú1³õÊ¼»¯ **************************************/
  80   1          P2M0 = P2M0 & 0x0F | 0x80;  // P21ÉèÖÃÎªÍÆÍìÊä³ö
  81   1          P0M1 = P0M1 & 0x0F | 0x20;  // P03ÉèÖÃÎªÉÏÀ­ÊäÈë
  82   1      
  83   1          TXD_MAP = 0x21;  // TXDÓ³ÉäP21
  84   1          RXD_MAP = 0x03;  // RXDÓ³ÉäP03
  85   1      
  86   1          BRTSEL = 0X00;  // UART1µÄ²¨ÌØÂÊ:00 T4
  87   1          T4CON  = 0x06;  // T4¹¤×÷Ä£Ê½£ºUART1²¨ÌØÂÊ·¢ÉúÆ÷
  88   1      
  89   1          TH4   = 0xFF;
  90   1          TL4   = 0x98;  // ²¨ÌØÂÊ9600
  91   1          SCON2 = 0x02;  // 8Î»UART£¬²¨ÌØÂÊ¿É±ä
  92   1      
  93   1          SCON = 0x10;  // ÔÊÐí´®ÐÐ½ÓÊÕ
  94   1          IE |= 0X10;   // Ê¹ÄÜ´®¿ÚÖÐ¶Ï
  95   1      
  96   1          EA = 1;  // ´ò¿ª×ÜÖÐ¶Ï
  97   1      
  98   1          /************************************ TIM0ÅäÖÃ³õÊ¼»¯ 1ms *****************************************/
  99   1          TCON1 = 0x00;  // Tx0¶¨Ê±Æ÷Ê±ÖÓÎªFosc
 100   1          TMOD  = 0x00;  // 16Î»ÖØ×°ÔØ¶¨Ê±Æ÷/¼ÆÊýÆ÷
 101   1      
 102   1          TH0 = 0xFA;
 103   1          TL0 = 0xCB;    // T0¶¨Ê±Ê±¼ä1ms
 104   1          IE |= 0x02;    // ´ò¿ªT0ÖÐ¶Ï
 105   1          TCON |= 0x10;  // Ê¹ÄÜT0
 106   1      
 107   1          /********************************** TIM1ÅäÖÃ³õÊ¼»¯ 25ms **************************************/
 108   1          TCON1 = 0x00;  // T1¶¨Ê±Æ÷Ê±ÖÓÎªFosc  Timer·ÖÆµÏµÊý = 12
 109   1          TMOD  = 0x00;  // 16Î»ÖØ×°ÔØ¶¨Ê±Æ÷/¼ÆÊýÆ÷
 110   1          TH1   = 0x7d;
 111   1          TL1   = 0xca;
 112   1          IE |= 0x08;    // ´ò¿ªT1ÖÐ¶Ï
 113   1          TCON |= 0x40;  // Ê¹ÄÜT1
 114   1      
 115   1          /************************************ADC³õÊ¼»¯*****************************************/
 116   1          P0M0 = P0M0 & 0xF0 | 0x03;  // P00ÉèÖÃÎªÄ£ÄâÊäÈë
C51 COMPILER V9.60.7.0   MAIN                                                              07/24/2023 09:28:48 PAGE 3   

 117   1          P0M1 = P0M1 & 0xF0 | 0x03;  // P02ÉèÖÃÎªÄ£ÄâÊäÈë
 118   1          P0M2 = P0M2 & 0xF0 | 0x03;  // P04ÉèÖÃÎªÄ£ÄâÊäÈë
 119   1          P0M3 = P0M3 & 0xF0 | 0x03;  // P06ÉèÖÃÎªÄ£ÄâÊäÈë
 120   1      
 121   1          ADCC0 = 0x81;   // ´ò¿ªADC×ª»»µçÔ´
 122   1          Delay_2us(10);  // ÑÓÊ±20us£¬È·±£ADCÏµÍ³ÎÈ¶¨
 123   1          ADCC1 = 0x00;   // Ñ¡ÔñÍâ²¿Í¨µÀ0
 124   1          ADCC2 = 0x4D;   // ×ª»»½á¹û12Î»Êý¾Ý£¬Êý¾ÝÓÒ¶ÔÆë£¬ADCÊ±ÖÓ16·ÖÆµ Fadc = 1MHz
 125   1      
 126   1          IP3 |= 0x0C;   //ADCÓÅÏÈ¼¶µ÷ÖÆ×î¸ß
 127   1          IE1 |= 0x20;  // ´ò¿ªADCÖÐ¶Ï
 128   1          EA = 1;
 129   1      
 130   1          ADCC0 &= ~0x20;  // Çå³ýADCÖÐ¶Ï±êÖ¾Î»
 131   1      //    ADCC0 |= 0x40;   // Æô¶¯ADC×ª»»
 132   1      
 133   1          /********************************** FlashÅäÖÃ³õÊ¼»¯ *************************************/
 134   1          FREQ_CLK = 0x10;  // Ö¸Ã÷µ±Ç°ÏµÍ³Ê±ÖÓ
 135   1      
 136   1          /*********************************** WDTÅäÖÃ³õÊ¼»¯ **************************************/
 137   1          WDTC   = 0x57;  // ÔÊÐíWDT¸´Î»£¬ÔÊÐíµôµç/¿ÕÏÐÄ£Ê½ÏÂÔËÐÐ£¬1024·ÖÆµ 5.93s
 138   1          WDTCCR = 0xFF;  // Ð´Èë00Ê±£¬½«¹Ø±ÕWDT¹¦ÄÜ£¨µ«²»¹Ø±ÕÄÚ²¿µÍÆµRC£©£¬
 139   1      
 140   1          /************************************* PWM³õÊ¼»¯ ****************************************/
 141   1          // ÆµÂÊÉèÖÃ·¶Î§£º489 - 2 000 000
 142   1      
 143   1          P2M1     = P2M1 & 0xF0 | 0x08;  // P22ÉèÖÃÎªÍÆÍìÊä³ö
 144   1          PWM0_MAP = 0x22;                // PWM0Í¨µÀÓ³ÉäP22¿Ú
 145   1          PWM0C    = 0x01;                // PWM0¸ßÓÐÐ§£¬PWM01¸ßÓÐÐ§£¬Ê±ÖÓ8·ÖÆµ
 146   1          PWM0PH   = 0x03;                // ÖÜÆÚ¸ß4Î»ÉèÖÃÎª0x03
 147   1          PWM0PL   = 0xFF;                // ÖÜÆÚµÍ8Î»ÉèÖÃÎª0xFF
 148   1          PWM0DH   = 0x01;                // PWM0¸ß4Î»Õ¼¿Õ±È0x01
 149   1          PWM0DL   = 0x55;                // PWM0µÍ8Î»Õ¼¿Õ±È0x55
 150   1          PWM0EN   = 0x0B;                // Ê¹ÄÜPWM0£¬¹¤×÷ÓÚ¶ÀÁ¢Ä£Ê½ PWM0Êä³ö PWM01¹Ø±Õ 0000 1011
 151   1      
 152   1          /************************************* Ö¸¶¨²¨ÐÎ ****************************************/
 153   1          P0M0 = P0M0 & 0x0F | 0x80;  //      P01ÉèÖÃÎªÍÆÍêÊä³ö
 154   1      
 155   1          /************************************* ¸ø¸÷Ïî²ÎÊýÉèÖÃ³õÖµ ****************************************/
 156   1          // ¶ÁÈ¡FlashÖÐµÄ¸÷Í¨µÀµçÑ¹ÏµÊý
 157   1          Flash_ReadArr(VolCoeFlashAddress, 16, VolCoeStore);
 158   1      
 159   1          for (i = 0; i < 4; i++) {
 160   2              memcpy(Vol_b.stByte.u8Byte, &VolCoeStore[i * 4], 4);
 161   2              VolCoe[i] = Vol_b.all;
 162   2          }
 163   1      
 164   1          // ´®¿Ú³¬Ê±ÅÐ¶Ï
 165   1          soft_timer_list_reset();
 166   1          add_timer(&usart1_timer, usart1_timeover_proc, 50);  // 50MS
 167   1          start_timer(&usart1_timer);
 168   1      
 169   1      
 170   1          // Çå¿Õ´®¿Ú½ÓÊÕ»º´æ
 171   1          memcpy(Uart1_rec.guc_Uartbuf_a, 0, 20);
 172   1      
 173   1      //    Uart1.FlagByte |= 0x01;  //´®¿Ú¿ÕÏÐ
 174   1      //    memcpy(Uart1.Data, 0, UART1BUFLEN);
 175   1      }
 176          
 177          /***************************************************************************************
 178           * @ËµÃ÷        ³õÊ¼»¯¹Ü½ÅÎªÍÆÍìÊä³ö
C51 COMPILER V9.60.7.0   MAIN                                                              07/24/2023 09:28:48 PAGE 4   

 179           * @²ÎÊý        IOPPx £ºÄÄÒ»×éIO
 180           *      @²ÎÊý   IOPPXx£ºÄ³Ò»¸öµÄÄÄÒ»¸öIO
 181           * @·µ»ØÖµ ÎÞ
 182           * @×¢            ÎÞ
 183           ***************************************************************************************/
 184          
 185          void IOInitPushpull(unsigned char IOPPx, unsigned char IOPPXx)
 186          {
 187   1      // ³õÊ¼»¯¹Ü½Å
 188   1          switch (IOPPx)
 189   1          {
 190   2              // P2
 191   2          case 0x02:
 192   2              switch (IOPPXx / 2)
 193   2              {
 194   3                  // P20 P21
 195   3              case 0:
 196   3                  (IOPPXx % 2) ? ( P2M0 = P2M0 & 0x0F | 0x80):(P2M0 = P2M0 & 0xF0 | 0x08);
 197   3                  break;
 198   3      
 199   3                  // P23 P22
 200   3              case 1:
 201   3                  (IOPPXx % 2) ? ( P2M1 = P2M1 & 0x0F | 0x80):(P2M1 = P2M1 & 0xF0 | 0x08);
 202   3                  break;
 203   3      
 204   3                  // P25 P24
 205   3              case 2:
 206   3                  (IOPPXx % 2) ? ( P2M2 = P2M2 & 0x0F | 0x80):(P2M2 = P2M2 & 0xF0 | 0x08);
 207   3                  break;
 208   3      
 209   3              case 3:
 210   3                  (IOPPXx % 2) ? ( P2M3 = P2M3 & 0x0F | 0x80):(P2M3 = P2M3 & 0xF0 | 0x08);
 211   3                  break;
 212   3      
 213   3              default:
 214   3                  break;
 215   3              }
 216   2              break;
 217   2      
 218   2              //P0
 219   2          case 0x00:
 220   2              switch (IOPPXx / 2)
 221   2              {
 222   3                  // P00 P01
 223   3              case 0:
 224   3                  (IOPPXx % 2) ? ( P0M0 = P0M0 & 0x0F | 0x80):(P0M0 = P0M0 & 0xF0 | 0x08);
 225   3                  break;
 226   3      
 227   3                  // P03 P02
 228   3              case 1:
 229   3                  (IOPPXx % 2) ? ( P0M1 = P0M1 & 0x0F | 0x80):(P0M1 = P0M1 & 0xF0 | 0x08);
 230   3                  break;
 231   3      
 232   3                  // P05 P04
 233   3              case 2:
 234   3                  (IOPPXx % 2) ? ( P0M2 = P0M2 & 0x0F | 0x80):(P0M2 = P0M2 & 0xF0 | 0x08);
 235   3                  break;
 236   3      
 237   3              case 3:
 238   3                  (IOPPXx % 2) ? ( P0M3 = P0M3 & 0x0F | 0x80):(P0M3 = P0M3 & 0xF0 | 0x08);
 239   3                  break;
 240   3      
C51 COMPILER V9.60.7.0   MAIN                                                              07/24/2023 09:28:48 PAGE 5   

 241   3              default:
 242   3                  break;
 243   3              }
 244   2              break;
 245   2      
 246   2          default:
 247   2              break;
 248   2          }
 249   1      }
 250          
 251          /***************************************************************************************
 252           * @ËµÃ÷        ADCÖÐ¶Ï·þÎñº¯Êý
 253           *      @²ÎÊý     ÎÞ
 254           * @·µ»ØÖµ ÎÞ
 255           * @×¢            ÎÞ
 256           ***************************************************************************************/
 257          void ADC_Rpt() interrupt ADC_VECTOR
 258          {
 259   1          // ¶ÁÈ¡ÊýÖµ
 260   1          ADCC0 &= ~0x20;  // Çå³ýADCÖÐ¶Ï±êÖ¾Î»
 261   1      
 262   1          gui_AdcValue_a[guc_Channel_Count] = ADCR;  // »ñÈ¡ADCÊý¾Ý
 263   1      
 264   1          guc_Channel_Count++;
 265   1          if (guc_Channel_Count == 4) {
 266   2              guc_Count++;
 267   2              guc_Channel_Count = 0;
 268   2              if (guc_Count == 64) {
 269   3                  guc_Count = 0;
 270   3              }
 271   2          }
 272   1      
 273   1          // ÇÐ»»Í¨µÀ
 274   1          ADCC1 = (ADCC1 & (~0x07)) | (guc_AdcChannel_a[guc_Channel_Count]);  // Ñ¡ÔñÍâ²¿Í¨µÀ
 275   1      //    Delay_2us(10);                                                      // ÇÐ»»Í¨µÀºó½¨ÒéÑÓÊ±20us
 276   1      }
 277          
 278          /***************************************************************************************
 279           * @ËµÃ÷        T0ÖÐ¶Ï·þÎñº¯Êý
 280           *      @²ÎÊý     ÎÞ
 281           * @·µ»ØÖµ ÎÞ
 282           * @×¢            ÎÞ
 283           ***************************************************************************************/
 284          void TIMER0_Rpt(void) interrupt TIMER0_VECTOR  // 1ms
 285          {
 286   1          // ´®¿Ú³¬Ê±ÅÐ¶Ï
 287   1          timer_periodic_refresh();
 288   1      
 289   1          // Æô¶¯×ª»»
 290   1          ADCC0 |= 0x40;  // Æô¶¯ÏÂÒ»´Î×ª»»
 291   1      
 292   1          // PWM¹¤×÷ÖÜÆÚÉèÖÃ
 293   1          PWMOut_count++;
 294   1          if (PWMOut_count > PWMWorkTime) {
 295   2              PWM0EN &= ~0x01;  // ¹Ø±ÕPWMÄ£¿é
 296   2          }
 297   1      
 298   1          if (PWMOut_count >= PWMOutCycle) {
 299   2              PWMOut_count = 0;
 300   2              PWM0EN |= 0x01;  // ´ò¿ªPWMÄ£¿é
 301   2          }
 302   1      }
C51 COMPILER V9.60.7.0   MAIN                                                              07/24/2023 09:28:48 PAGE 6   

 303          
 304          /**
 305           * @ËµÃ÷        ÑÓÊ±º¯Êý
 306           * @²ÎÊý        fui_i : ÑÓÊ±Ê±¼ä
 307           * @·µ»ØÖµ ÎÞ
 308           * @×¢  Fcpu = 16MHz,fui_i = 1Ê±,ÑÓÊ±Ê±¼äÔ¼Îª2us
 309           */
 310          void Delay_2us(unsigned int fui_i)
 311          {
 312   1          while (fui_i--)
 313   1              ;
 314   1      }
 315          
 316          /***************************************************************************************
 317           * @ËµÃ÷        UART1ÖÐ¶Ï·þÎñº¯Êý
 318           *      @²ÎÊý     ÎÞ
 319           * @·µ»ØÖµ ÎÞ
 320           * @×¢            ÎÞ
 321           ***************************************************************************************/
 322          void UART1_Rpt(void) interrupt UART1_VECTOR
 323          {
 324   1          static unsigned char UartsdfCnt = 0, UsartRecflg = 0, temp = 0;
 325   1      
 326   1          /* ´®¿Ú½ÓÊÜÖÐ¶Ï */
 327   1          if (SCON & 0x01)  // ÅÐ¶Ï½ÓÊÕÖÐ¶Ï±êÖ¾Î»
 328   1          {
 329   2              reload_timer(&usart1_timer, 50);  // ÈôÓÐ×Ö·ûÊÕµ½£¬×°³õÖµ²¢Æô¶¯¶¨Ê±Æ÷£¬Èô×Ö½Ú³¬Ê±£¬Ôò»á×Ô¶¯µ÷ÓÃ¶¨Ê
             -±Æ÷³¬Ê±º¯Êý,³¬Ê±ÉèÎª50ms
 330   2              start_timer(&usart1_timer);
 331   2      
 332   2              if (UsartRecflg)  // ¿ªÊ¼½ÓÊÕÊý¾Ý
 333   2              {
 334   3                  Uart1_rec.guc_Uartbuf_temp[Uart1_rec.guc_Uartcnt++] = SBUF;  // ×ª´æ8Î»´®¿Ú½ÓÊÕÊý¾Ý
 335   3              }
 336   2      
 337   2              // Ö¡Í·
 338   2              if (SBUF ==   0xff)  // ÅÐ¶ÏÓÐÃ»ÓÐ¿ÉÄÜÊÇÖ¡Í·
 339   2              {
 340   3                  UartsdfCnt++;
 341   3              }
 342   2              else {
 343   3                  UartsdfCnt = 0;
 344   3              }
 345   2      
 346   2              if (UartsdfCnt == 2)  // ½ÓÊÕµ½Ö¡Í·(2¸ö0xff),¿ªÊ¼½ÓÊÕÊý¾Ý
 347   2              {
 348   3                  UsartRecflg = 1;
 349   3      
 350   3                  Uart1_rec.guc_Uartcnt = 0;  // ¿ªÊ¼½ÓÊÕÊý¾Ý£¬ÇåÁã¼ÆÊý
 351   3      
 352   3                  // Çå¿Õ´®¿Ú½ÓÊÕ»º´æ
 353   3                  memcpy(Uart1_rec.guc_Uartbuf_temp, 0, 20);
 354   3              }
 355   2      
 356   2              // ½ÓÊÕµÄÊý¾ÝÌ«¶à
 357   2              if (Uart1_rec.guc_Uartcnt >= 20) {
 358   3                  Uart1_rec.guc_Uartflag = 1;
 359   3                  memcpy(Uart1_rec.guc_Uartbuf_a, 0, 20);
 360   3                  memcpy(Uart1_rec.guc_Uartbuf_a, Uart1_rec.guc_Uartbuf_temp,Uart1_rec.guc_Uartcnt);
 361   3                  Uart1_rec.guc_Uartcnt  = 0;
 362   3              }
 363   2      
C51 COMPILER V9.60.7.0   MAIN                                                              07/24/2023 09:28:48 PAGE 7   

 364   2              SCON &= ~0x01;  // Çå³ý½ÓÊÕÖÐ¶Ï±êÖ¾Î»
 365   2          }
 366   1      
 367   1          /* ´®¿Ú·¢ËÍÖÐ¶Ï */
 368   1          if (SCON & 0x02)  // ÅÐ¶Ï·¢ËÍÖÐ¶Ï±êÖ¾Î»
 369   1          {
 370   2              if (ringBuff.Lenght) //»º´æÇøÓÐÊý¾Ý 
 371   2              {
 372   3                  if (Read_RingBuff(&temp,&ringBuff))
 373   3                  {
 374   4                      SBUF = temp;
 375   4                  }
 376   3              }
 377   2              else //»º´æÇøÃ»ÓÐÊý¾Ý
 378   2              {
 379   3                  ringBuff.FlagByte |= 0x01;    //´®¿Ú¿ÕÏÐ 
 380   3              }
 381   2      
 382   2              SCON &= ~0x02;  // Çå³ý·¢ËÍÖÐ¶Ï±êÖ¾Î»
 383   2          }
 384   1      }
 385          
 386          /***************************************************************************************
 387           * @ËµÃ÷        ´®¿Ú1¶¨Ê±Æ÷×Ö½Ú³¬Ê±´¦Àí
 388           *      @²ÎÊý   ÎÞ
 389           * @·µ»ØÖµ ÎÞ
 390           * @×¢          ÎÞ
 391           ***************************************************************************************/
 392          void usart1_timeover_proc(void)
 393          {
 394   1      //    SCON &= ~0x10;  // Ê§ÄÜUART1½ÓÊÕ
 395   1          memcpy(Uart1_rec.guc_Uartbuf_a, 0, 20);
 396   1          memcpy(Uart1_rec.guc_Uartbuf_a, Uart1_rec.guc_Uartbuf_temp,Uart1_rec.guc_Uartcnt); //±£´æ½ÓÊÕµ½µÄÊý¾Ý
 397   1      
 398   1          Uart1_rec.guc_Uartflag = 1;
 399   1          Uart1_rec.guc_Uartcnt  = 0;
 400   1      }
 401          
 402          /**
 403           * @ËµÃ÷        Ð´ÈëÒ»¸ö×Ö½ÚÊý¾Ýµ½FlashÀïÃæ
 404           * @²ÎÊý        fui_Address £ºFLASHµØÖ·
 405           *      @²ÎÊý   fucp_SaveData£ºÐ´ÈëµÄÊý¾Ý´æ·ÅÇøÓòµÄÊ×µØÖ·
 406           * @·µ»ØÖµ ÎÞ
 407           * @×¢          Ð´Ö®Ç°±ØÐëÏÈ¶Ô²Ù×÷µÄÉÈÇø½øÐÐ²Á³ý
 408           */
 409          #pragma disable  // È·±£µ÷ÕûÊ±²»»á½øÖÐ¶Ïµ¼ÖÂµ÷ÕûÊ§°Ü
 410          void FLASH_WriteData(unsigned char fuc_SaveData, unsigned int fui_Address)
 411          {
 412   1          IAP_DATA = fuc_SaveData;
 413   1          IAP_CMD  = 0xF00F;  // Flash½âËø
 414   1          IAP_ADDR = fui_Address;
 415   1          IAP_CMD  = 0xB44B;  // ×Ö½Ú±à³Ì
 416   1          IAP_CMD  = 0xE11E;  // ´¥·¢Ò»´Î²Ù×÷
 417   1      }
 418          
 419          /**
 420           * @ËµÃ÷        Ð´ÈëÈÎÒâ³¤¶ÈµÄÊý¾Ýµ½FLASHÀïÃæ
 421           * @²ÎÊý        fui_Address £ºFLASHÆðÊ¼µØÖ·
 422           *      @²ÎÊý   fuc_Length £º Ð´ÈëÊý¾Ý³¤¶È
 423           *                          È¡Öµ·¶Î§£º0x00-0xFF
 424           *      @²ÎÊý    *fucp_SaveArr£ºÐ´ÈëµÄÊý¾Ý´æ·ÅÇøÓòµÄÊ×µØÖ·
 425           * @·µ»ØÖµ ÎÞ
C51 COMPILER V9.60.7.0   MAIN                                                              07/24/2023 09:28:48 PAGE 8   

 426           * @×¢            Ð´Ö®Ç°±ØÐëÏÈ¶Ô²Ù×÷µÄÉÈÇø½øÐÐ²Á³ý
 427           */
 428          #pragma disable  // È·±£µ÷ÕûÊ±²»»á½øÖÐ¶Ïµ¼ÖÂµ÷ÕûÊ§°Ü
 429          void Flash_WriteArr(unsigned int fui_Address, unsigned char fuc_Length, unsigned char* fucp_SaveArr)
 430          {
 431   1          unsigned char fui_i = 0;
 432   1          for (fui_i = 0; fui_i < fuc_Length; fui_i++) {
 433   2              FLASH_WriteData(*(fucp_SaveArr++), fui_Address++);
 434   2          }
 435   1      }
 436          
 437          /**
 438           * @ËµÃ÷        ´ÓFLASHÀïÃæ¶ÁÈ¡ÈÎÒâ³¤¶ÈµÄÊý¾Ý
 439           * @²ÎÊý        fui_Address £ºFLASHÆðÊ¼µØÖ·
 440           * @²ÎÊý          fuc_Length £º¶ÁÈ¡Êý¾Ý³¤¶È
 441           *                          È¡Öµ·¶Î§£º0x00-0xFF
 442           * @²ÎÊý         *fucp_SaveArr£º¶ÁÈ¡Êý¾Ý´æ·ÅµÄÇøÓòÊ×µØÖ·
 443           * @·µ»ØÖµ ÎÞ
 444           * @×¢            ÎÞ
 445           */
 446          void Flash_ReadArr(unsigned int fui_Address, unsigned char fuc_Length, unsigned char* fucp_SaveArr)
 447          {
 448   1          while (fuc_Length--) *(fucp_SaveArr++) = *((unsigned char code*)(fui_Address++));  // ¶ÁÈ¡Êý¾Ý
 449   1      }
 450          
 451          /**
 452           * @ËµÃ÷        ÉÈÇø²Á³ý£¬Ô¼ÏûºÄ5msµÄÊ±¼ä
 453           * @²ÎÊý        fui_Address £º±»²Á³ýµÄÉÈÇøÄÚµÄÈÎÒâÒ»¸öµØÖ·
 454           * @·µ»ØÖµ ÎÞ
 455           * @×¢            Ö»Òª²Ù×÷ÉÈÇøÀïÃæµÄÈÎÒâÒ»¸öµØÖ·£¬¾Í¿ÉÒÔ²Á³ý´ËÉÈÇø
 456           */
 457          #pragma disable  // È·±£µ÷ÕûÊ±²»»á½øÖÐ¶Ïµ¼ÖÂµ÷ÕûÊ§°Ü
 458          void Flash_EraseBlock(unsigned int fui_Address)
 459          {
 460   1          IAP_CMD  = 0xF00F;       // Flash½âËø
 461   1          IAP_ADDR = fui_Address;  // Ð´Èë²Á³ýµØÖ·
 462   1          IAP_CMD  = 0xD22D;       // Ñ¡Ôñ²Ù×÷·½Ê½£¬ ÉÈÇø²Á³ý
 463   1          IAP_CMD  = 0xE11E;       // ´¥·¢ºóIAP_ADDRL&IAP_ADDRHÖ¸Ïò0xFF£¬Í¬Ê±×Ô¶¯Ëø¶¨
 464   1      }
 465          
 466          /***************************************************************************************
 467           * @ËµÃ÷        T1ÖÐ¶Ï·þÎñº¯Êý
 468           *      @²ÎÊý     ÎÞ
 469           * @·µ»ØÖµ ÎÞ
 470           * @×¢            ÎÞ
 471           ***************************************************************************************/
 472          void TIMER1_Rpt(void) interrupt TIMER1_VECTOR  // 25msÖÐ¶Ï
 473          {
 474   1          static unsigned int count = 0;
 475   1          count++;
 476   1          if (count >= 4) 
 477   1          {
 478   2              count = 0;
 479   2              // Êä³öÖ¸¶¨²¨ÐÎ
 480   2              switch (SpecifywaveIOflag) 
 481   2              {
 482   3                  // P01
 483   3                  case 0:P0_1 = SpecifywaveformOut[SpecifywaveCount];break;
 484   3      
 485   3                  // P05
 486   3                  case 1:P0_5 = SpecifywaveformOut[SpecifywaveCount];break;
 487   3      
C51 COMPILER V9.60.7.0   MAIN                                                              07/24/2023 09:28:48 PAGE 9   

 488   3                  // P07
 489   3                  case 2:P0_7 = SpecifywaveformOut[SpecifywaveCount];break;
 490   3      
 491   3                  default:break;
 492   3              }
 493   2              SpecifywaveCount++;
 494   2              if (SpecifywaveCount > 14) SpecifywaveCount = 0;
 495   2          }
 496   1      }
 497          
 498          /***************************************************************************************
 499           * @ËµÃ÷        Ö¸ÁîÂÖÑµº¯Êý
 500           * @²ÎÊý    ÎÞ
 501           * @·µ»ØÖµ  ÎÞ
 502           * @×¢      ÎÞ
 503           ***************************************************************************************/
 504          void poll_task(u8 cmd)
 505          {
 506   1          int cmd_index = 0;
 507   1      
 508   1          for (cmd_index = 0; cmd_index < 5; cmd_index++)
 509   1          {
 510   2              if (callback_list[cmd_index].CMD == cmd)
 511   2              {
 512   3                  callback_list[cmd_index].callback_func(Uart1_rec.guc_Uartbuf_a);
 513   3              }
 514   2          }
 515   1      
 516   1      }
 517          
 518          /***************************************************************************************
 519           * @ËµÃ÷        ¹¦ÄÜ£º²éÑ¯Í¨µÀµçÑ¹ µÄ»Øµ÷º¯Êý
 520           * @²ÎÊý    ÎÞ
 521           * @·µ»ØÖµ  ÎÞ
 522           * @×¢      ÎÞ
 523           ***************************************************************************************/
 524          /*********************** 1 ²éÑ¯Í¨µÀµçÑ¹ ***********************/
 525          // ¹Ü½Å: P00 P02 P04 P06
 526          // »º´æÇøÊý¾Ý£º0x01£¬Í¨µÀÑ¡Ôñ£¨1¸ö×Ö½Ú£©
 527          void callback_QueryVoltage(unsigned char *myStr)
 528          {
 529   1          u8 ANx = 0;
 530   1          float UARTprintVolCoe = 0;
 531   1          if (myStr[1] == 0x00 ||
 532   1              myStr[1] == 0x02 ||
 533   1              myStr[1] == 0x04 ||
 534   1              myStr[1] == 0x06)
 535   1          {
 536   2              ANx = (int)myStr[1]/2;
 537   2              UARTprintVolCoe = (float)(gui_AdcValue_a[ANx] / 4096.0) * VDD * VolCoe[ANx];
 538   2              sprintf(guc_Uartbuf_p,"AN%d = %f\r\n", (int)myStr[1],UARTprintVolCoe);
 539   2          }
 540   1          else
 541   1          {
 542   2              sprintf(guc_Uartbuf_p,"¸ÃÍ¨µÀ²»´æÔÚ£¡\r\n");
 543   2          }
 544   1          
 545   1          
 546   1      //    sprintf(guc_Uartbuf_p,"¹¦ÄÜ1\r\n");
 547   1      }
 548          
 549          
C51 COMPILER V9.60.7.0   MAIN                                                              07/24/2023 09:28:48 PAGE 10  

 550          /***************************************************************************************
 551           * @ËµÃ÷        ¹¦ÄÜ£ºÐÞ¸ÄÖ¸¶¨Í¨µÀµçÑ¹²ÎÊý µÄ»Øµ÷º¯Êý
 552           * @²ÎÊý    ÎÞ
 553           * @·µ»ØÖµ  ÎÞ
 554           * @×¢      ÎÞ
 555           ***************************************************************************************/
 556          /*********************** 2 ÐÞ¸ÄÖ¸¶¨Í¨µÀµçÑ¹²ÎÊý ***********************/
 557          // ¹Ü½Å: P00 P02 P04 P06
 558          // »º´æÇøÊý¾Ý£º0x02£¬Í¨µÀÑ¡Ôñ£¨1¸ö×Ö½Ú£©£¬µçÑ¹ÏµÊý£¨4¸ö×Ö½Ú£¬float£©
 559          void callback_ModifyVoltageParameters(unsigned char *myStr)
 560          {
 561   1          if (myStr[1] == 0x00 || myStr[1] == 0x02 || myStr[1] == 0x04 || myStr[1] == 0x06)
 562   1          {
 563   2              memcpy(Vol_a.stByte.u8Byte, &myStr[2], 4);
 564   2              VolCoe[(int)myStr[1] / 2] = Vol_a.all;
 565   2      
 566   2              for (i = 0; i < 4; i++)
 567   2              {
 568   3                  Vol_b.all = VolCoe[i];
 569   3                  memcpy(&VolCoeStore[i * 4], Vol_b.stByte.u8Byte, 4);
 570   3              }
 571   2              Flash_EraseBlock(VolCoeFlashAddress);                 // ²Á³ýµØÖ·0x3B00ËùÔÚÉÈÇø
 572   2              Flash_WriteArr(VolCoeFlashAddress, 16, VolCoeStore);  // ÔÚµØÖ·0x3B00Ð´ÈëÊý¾Ý
 573   2              sprintf(guc_Uartbuf_p,"ok!\r\nVolCoe: %f - %f - %f - %f\r\n", VolCoe[0], VolCoe[1], VolCoe[2], Vol
             -Coe[3]);
 574   2          }
 575   1          else
 576   1          {
 577   2              sprintf(guc_Uartbuf_p,"ÉèÖÃ´íÎó!\r\n");
 578   2          }
 579   1          
 580   1      //    sprintf(guc_Uartbuf_p,"¹¦ÄÜ2\r\n");
 581   1      }
 582          
 583          /***************************************************************************************
 584           * @ËµÃ÷        ¹¦ÄÜ£ºÖ¸¶¨PWM²¨ÊµÏÖ¹Ü½Å£¬ÆµÂÊºÍÕ¼¿Õ±È µÄ»Øµ÷º¯Êý
 585           * @²ÎÊý    ÎÞ
 586           * @·µ»ØÖµ  ÎÞ
 587           * @×¢      ÎÞ
 588           ***************************************************************************************/
 589          /*********************** 3 Ö¸¶¨PWM²¨ÊµÏÖ¹Ü½Å£¬ÆµÂÊºÍÕ¼¿Õ±È ***********************/
 590          // ¹Ü½Å: P20 P22 P23 P24 P25 P26 P27    ÆµÂÊ£º489 - 2M   Õ¼¿Õ±È£º0 - 100
 591          // »º´æÇøÊý¾Ý£º0x03£¬¹Ü½ÅÑ¡Ôñ£¨1¸ö×Ö½Ú£©£¬ÆµÂÊ£¨3¸ö×Ö½Ú£©£¬Õ¼¿Õ±È£¨1¸ö×Ö½Ú£©
 592          void callback_ModifyPWMParameter(unsigned char *myStr)
 593          {
 594   1          strChar           IOPP;
 595   1          unsigned long int PWMFrequency = 0;
 596   1          unsigned int      PWMCycle = 0, PWMDutycycle = 0;  // PWMCycle - ´æ·ÅPWM²¨µÄÖÜÆÚ  PWMDutycycle - ´æ·ÅP
             -WMÕ¼¿Õ±ÈµÄ¾ßÌåÊýÖµ
 597   1      
 598   1          // ÅÐ¶Ï¹Ü½ÅÑ¡ÔñÊý¾ÝÊÇ·ñ·ûºÏÌõ¼þ
 599   1          IOPP.byte = myStr[1];
 600   1          
 601   1          if ((myStr[1] & 0xc8) != 0x00) 
 602   1          {
 603   2              sprintf(guc_Uartbuf_p,"Ö¸¶¨PWMÊä³ö¹Ü½Å´íÎó!\r\n");
 604   2              return ;
 605   2          }
 606   1      
 607   1      
 608   1          if (IOPP.half.low != 0x02) 
 609   1          {
C51 COMPILER V9.60.7.0   MAIN                                                              07/24/2023 09:28:48 PAGE 11  

 610   2              sprintf(guc_Uartbuf_p,"Ö¸¶¨PWMÊä³ö¹Ü½Å´íÎó!\r\n");
 611   2              return ;
 612   2          }
 613   1      
 614   1          if (IOPP.half.high == 0x01) 
 615   1          {
 616   2              sprintf(guc_Uartbuf_p,"Ö¸¶¨PWMÊä³ö¹Ü½Å´íÎó!\r\n");
 617   2              return ;
 618   2          }
 619   1        
 620   1      
 621   1          // ÆµÂÊÊÇ·ñ³¬¹ýÏÞÖÆ
 622   1          PWMFrequency = (myStr[2] * 65536 + myStr[3] * 256 + myStr[4]);
 623   1          
 624   1          if (PWMFrequency < 489)
 625   1          {
 626   2              sprintf(guc_Uartbuf_p,"PWM ÆµÂÊÌ«Ð¡\r\n");
 627   2              return ;
 628   2          }
 629   1          else if (PWMFrequency > 2000000)
 630   1          {
 631   2              sprintf(guc_Uartbuf_p,"PWM ÆµÂÊÌ«´ó\r\n");
 632   2              return ;
 633   2          }
 634   1      
 635   1          // Õ¼¿Õ±ÈÊÇ·ñ³¬¹ýÏÞÖÆ
 636   1          if ((int)myStr[5] > 100)
 637   1          {
 638   2              sprintf(guc_Uartbuf_p,"PWM Õ¼¿Õ±ÈÌ«´ó\r\n");
 639   2              return ;
 640   2          }
 641   1      
 642   1          // ÅäÖÃIOÎªÍÆÍêÊä³ö
 643   1          IOInitPushpull(IOPP.half.low, IOPP.half.high);
 644   1      
 645   1          // PWMÊä³ö¹Ü½ÅÖØÓ³Éä
 646   1          PWM0_MAP = myStr[1];
 647   1      
 648   1          // ÆµÂÊÉèÖÃ£¨ÖÜÆÚ£©
 649   1          PWMCycle = 2000000 / PWMFrequency;
 650   1          PWM0PH   = (PWMCycle >> 8) & 0xff;
 651   1          PWM0PL   = PWMCycle & 0xff;
 652   1      
 653   1          // Õ¼¿Õ±ÈÉèÖÃ
 654   1          PWMDutycycle = (unsigned int)(PWMCycle * (float)myStr[5] / 100.0);
 655   1          PWM0DH = (PWMDutycycle >> 8) & 0x0f;
 656   1          PWM0DL = (PWMDutycycle)&0xff;
 657   1      
 658   1          sprintf(guc_Uartbuf_p,"PWM²¨ÉèÖÃ³É¹¦,IO:P%d%d, ÆµÂÊ:%ld, Õ¼¿Õ±È:%u%%\r\n",(int)IOPP.half.low, (int)IOP
             -P.half.high, (long int)PWMFrequency, (unsigned int)myStr[5]);
 659   1              
 660   1      //    sprintf(guc_Uartbuf_p,"¹¦ÄÜ3\r\n");
 661   1      }
 662          
 663          /***************************************************************************************
 664           * @ËµÃ÷        ¹¦ÄÜ£ºÖ¸¶¨PWMÊä³öÖÜÆÚºÍ¹¤×÷Ê±¼ä µÄ»Øµ÷º¯Êý
 665           * @²ÎÊý    ÎÞ
 666           * @·µ»ØÖµ  ÎÞ
 667           * @×¢      ÎÞ
 668           ***************************************************************************************/
 669          /*********************** 4 Ö¸¶¨PWMÊä³öÖÜÆÚºÍ¹¤×÷Ê±¼ä ***********************/
 670          // »º´æÇøÊý¾Ý£º0x04£¬²úÉúÖÜÆÚ£¨2¸ö×Ö½Ú£©£¬¹¤×÷Ê±¼ä£¨2¸ö×Ö½Ú£©
C51 COMPILER V9.60.7.0   MAIN                                                              07/24/2023 09:28:48 PAGE 12  

 671          void callback_PWMOperatingParameters(unsigned char *myStr)
 672          {
 673   1          PWMOutCycle = myStr[1] * 256 + myStr[2];
 674   1          PWMWorkTime = myStr[3] * 256 + myStr[4];
 675   1          sprintf(guc_Uartbuf_p,"PWM¹¤×÷ÖÜÆÚ = %dms   ¹¤×÷Ê±¼ä = %dms\r\n", PWMOutCycle, PWMWorkTime);
 676   1          
 677   1      //    sprintf(guc_Uartbuf_p,"¹¦ÄÜ4\r\n");
 678   1      }
 679          
 680          /***************************************************************************************
 681           * @ËµÃ÷        ¹¦ÄÜ£ºÊä³öÖ¸¶¨²¨ÐÎ µÄ»Øµ÷º¯Êý
 682           * @²ÎÊý    ÎÞ
 683           * @·µ»ØÖµ  ÎÞ
 684           * @×¢      ÎÞ
 685           ***************************************************************************************/
 686          /*********************** 5 Êä³öÖ¸¶¨²¨ÐÎ P01 P05 P07 ***********************/
 687          // ¹Ü½Å: P01 P05 P07
 688          // »º´æÇøÊý¾Ý£º0x05£¬¹Ü½ÅÑ¡Ôñ£¨1¸ö×Ö½Ú£©  //fixme ÎªÊ²Ã´Ê¹ÓÃPWMÊµÏÖÖ¸¶¨²¨ÐÎ£¿100msµÄÖÜÆÚÈçºÎÊµÏÖµÄ£¿
 689          void callback_SpecifyWaveform(unsigned char *myStr)
 690          {
 691   1          strChar  IOPP;
 692   1          
 693   1          IOPP.byte = Uart1_rec.guc_Uartbuf_a[1];
 694   1      
 695   1          if (myStr[1] == 0x01 ||
 696   1              myStr[1] == 0x05 ||
 697   1              myStr[1] == 0x07)
 698   1          {
 699   2              // ÅäÖÃIOÎªÍÆÍêÊä³ö P01 P05 P07
 700   2              IOInitPushpull(IOPP.half.low, IOPP.half.high);
 701   2              SpecifywaveCount = 0;
 702   2      
 703   2              sprintf(guc_Uartbuf_p,"ÉèÖÃÖ¸¶¨²¨ÐÎÊä³ö¹Ü½ÅÎª:P%d%d\r\n", (int)IOPP.half.low, (int)IOPP.half.high)
             -;
 704   2          }
 705   1          else
 706   1          {
 707   2              sprintf(guc_Uartbuf_p,"Ö¸¶¨²¨ÐÎÊä³ö¹Ü½Å´íÎó!\r\n");
 708   2          }
 709   1      
 710   1      //    sprintf(guc_Uartbuf_p,"¹¦ÄÜ5\r\n");
 711   1      }
 712          
 713          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3205    ----
   CONSTANT SIZE    =    301    ----
   XDATA SIZE       =    281      39
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
