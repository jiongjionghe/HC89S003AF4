C51 COMPILER V9.60.7.0   MAIN                                                              07/24/2023 16:59:30 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\user\main.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\HAEDWARE\soft_ti
                    -mer;..\HAEDWARE\uart_Ringbuf) DEBUG OBJECTEXTEND PRINT(.\Listings\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "main.h"
   2          /***************************************************************************************
   3            * @ÊµÏÖÐ§¹û   ½×¶ÎÈý
   4          ¶¨Ê±Æ÷0£º 1ms
   5          ¶¨Ê±Æ÷1:  25ms
   6          
   7          ADCÍ¨µÀ£º
   8          AN0 - P00
   9          AN2 - P02
  10          AN4 - P04
  11          AN6 - P06
  12          
  13          ´®¿Ú£º
  14          RXD - P21
  15          TXD - P03
  16          
  17          PWM:
  18          PWM0  - P20 P22 P23 P24 P25 P26 P27
  19          
  20          Ö¸¶¨²¨ÐÎ:
  21          P01 P05 P07
  22          ***************************************************************************************/
  23          void main(void)
  24          {
  25   1          SystemInit();
  26   1          RingBuff_Init(&ringBuff);
  27   1      
  28   1          while (1)
  29   1          {
  30   2              WDTC |= 0x10;  // Çå¹·
  31   2      
  32   2              if (Uart1_rec.guc_Uartflag)
  33   2              {
  34   3                  memcpy(guc_Uartbuf_p, 0, UART1BUFLEN);
  35   3                  
  36   3                  // ¹¦ÄÜÑ¡Ôñ
  37   3                  if (Uart1_rec.guc_Uartbuf_a[0] > 0 && Uart1_rec.guc_Uartbuf_a[0] < 6)
  38   3                  {
  39   4                      poll_task(Uart1_rec.guc_Uartbuf_a[0]);
  40   4                  }
  41   3                  else
  42   3                  {
  43   4                      sprintf(guc_Uartbuf_p,"Ã»ÓÐ¸ÃÃüÁî£¡\r\n");
  44   4                  }
  45   3                  
  46   3                  // Çå¿ÕÃüÁî´æ·ÅÇø
  47   3                  memcpy(Uart1_rec.guc_Uartbuf_a, 0, 20);
  48   3      
  49   3                  // Êý¾ÝÖ¡½âÎö½áÊø
  50   3                  Uart1_rec.guc_Uartflag = 0;
  51   3                  
  52   3                  //½«Êý¾ÝÐ´Èë·¢ËÍ»º³åÇø
  53   3                  WriteStr_RingBuff(guc_Uartbuf_p,&ringBuff);
  54   3                  
C51 COMPILER V9.60.7.0   MAIN                                                              07/24/2023 16:59:30 PAGE 2   

  55   3                  
  56   3                  /* Æô¶¯´®¿Ú·¢ËÍ */
  57   3                  if (ringBuff.FlagByte & 0x01) 
  58   3                  {
  59   4                      ringBuff.FlagByte &= ~0x01;  //´®¿ÚÃ¦
  60   4                      TI = 1;
  61   4                  }
  62   3              }
  63   2          }
  64   1      }
  65          
  66          /***************************************************************************************
  67           * @ËµÃ÷        ³õÊ¼»¯ËùÓÐÍâÉè
  68           *      @²ÎÊý     ÎÞ
  69           * @·µ»ØÖµ ÎÞ
  70           * @×¢            ÎÞ
  71           ***************************************************************************************/
  72          
  73          void SystemInit(void)
  74          {
  75   1          /************************************ ÏµÍ³³õÊ¼»¯ ****************************************/
  76   1          //    WDTCCR = 0x00;                                                //¹Ø±Õ¿´ÃÅ¹·
  77   1          CLKSWR = 0x51;  // Ñ¡ÔñÄÚ²¿¸ßÆµRCÎªÏµÍ³Ê±ÖÓ£¬ÄÚ²¿¸ßÆµRC 2·ÖÆµ£¬Fosc=16MHz
  78   1          CLKDIV = 0x01;  // Fosc 1·ÖÆµµÃµ½Fcpu£¬Fcpu=16MHz
  79   1      
  80   1          /********************************** ´®¿Ú1³õÊ¼»¯ **************************************/
  81   1          P2M0 = P2M0 & 0x0F | 0x80;  // P21ÉèÖÃÎªÍÆÍìÊä³ö
  82   1          P0M1 = P0M1 & 0x0F | 0x20;  // P03ÉèÖÃÎªÉÏÀ­ÊäÈë
  83   1      
  84   1          TXD_MAP = 0x21;  // TXDÓ³ÉäP21
  85   1          RXD_MAP = 0x03;  // RXDÓ³ÉäP03
  86   1      
  87   1          BRTSEL = 0X00;  // UART1µÄ²¨ÌØÂÊ:00 T4
  88   1          T4CON  = 0x06;  // T4¹¤×÷Ä£Ê½£ºUART1²¨ÌØÂÊ·¢ÉúÆ÷
  89   1      
  90   1          TH4   = 0xFF;
  91   1          TL4   = 0x98;  // ²¨ÌØÂÊ9600
  92   1          SCON2 = 0x02;  // 8Î»UART£¬²¨ÌØÂÊ¿É±ä
  93   1      
  94   1          SCON = 0x10;  // ÔÊÐí´®ÐÐ½ÓÊÕ
  95   1          IE |= 0X10;   // Ê¹ÄÜ´®¿ÚÖÐ¶Ï
  96   1      
  97   1          EA = 1;  // ´ò¿ª×ÜÖÐ¶Ï
  98   1      
  99   1          /************************************ TIM0ÅäÖÃ³õÊ¼»¯ 1ms *****************************************/
 100   1          TCON1 = 0x00;  // Tx0¶¨Ê±Æ÷Ê±ÖÓÎªFosc
 101   1          TMOD  = 0x00;  // 16Î»ÖØ×°ÔØ¶¨Ê±Æ÷/¼ÆÊýÆ÷
 102   1      
 103   1          TH0 = 0xFA;
 104   1          TL0 = 0xCB;    // T0¶¨Ê±Ê±¼ä1ms
 105   1          IE |= 0x02;    // ´ò¿ªT0ÖÐ¶Ï
 106   1          TCON |= 0x10;  // Ê¹ÄÜT0
 107   1      
 108   1          /********************************** TIM1ÅäÖÃ³õÊ¼»¯ 25ms **************************************/
 109   1          TCON1 = 0x00;  // T1¶¨Ê±Æ÷Ê±ÖÓÎªFosc  Timer·ÖÆµÏµÊý = 12
 110   1          TMOD  = 0x00;  // 16Î»ÖØ×°ÔØ¶¨Ê±Æ÷/¼ÆÊýÆ÷
 111   1          TH1   = 0x7d;
 112   1          TL1   = 0xca;
 113   1          IE |= 0x08;    // ´ò¿ªT1ÖÐ¶Ï
 114   1          TCON |= 0x40;  // Ê¹ÄÜT1
 115   1      
 116   1          /************************************ADC³õÊ¼»¯*****************************************/
C51 COMPILER V9.60.7.0   MAIN                                                              07/24/2023 16:59:30 PAGE 3   

 117   1          P0M0 = P0M0 & 0xF0 | 0x03;  // P00ÉèÖÃÎªÄ£ÄâÊäÈë
 118   1          P0M1 = P0M1 & 0xF0 | 0x03;  // P02ÉèÖÃÎªÄ£ÄâÊäÈë
 119   1          P0M2 = P0M2 & 0xF0 | 0x03;  // P04ÉèÖÃÎªÄ£ÄâÊäÈë
 120   1          P0M3 = P0M3 & 0xF0 | 0x03;  // P06ÉèÖÃÎªÄ£ÄâÊäÈë
 121   1      
 122   1          ADCC0 = 0x81;   // ´ò¿ªADC×ª»»µçÔ´
 123   1          Delay_2us(10);  // ÑÓÊ±20us£¬È·±£ADCÏµÍ³ÎÈ¶¨
 124   1          ADCC1 = 0x00;   // Ñ¡ÔñÍâ²¿Í¨µÀ0
 125   1          ADCC2 = 0x4D;   // ×ª»»½á¹û12Î»Êý¾Ý£¬Êý¾ÝÓÒ¶ÔÆë£¬ADCÊ±ÖÓ16·ÖÆµ Fadc = 1MHz
 126   1      
 127   1          IP3 |= 0x0C;   //ADCÓÅÏÈ¼¶µ÷ÖÆ×î¸ß
 128   1          IE1 |= 0x20;  // ´ò¿ªADCÖÐ¶Ï
 129   1          EA = 1;
 130   1      
 131   1          ADCC0 &= ~0x20;  // Çå³ýADCÖÐ¶Ï±êÖ¾Î»
 132   1      //    ADCC0 |= 0x40;   // Æô¶¯ADC×ª»»
 133   1      
 134   1          /********************************** FlashÅäÖÃ³õÊ¼»¯ *************************************/
 135   1          FREQ_CLK = 0x10;  // Ö¸Ã÷µ±Ç°ÏµÍ³Ê±ÖÓ
 136   1      
 137   1          /*********************************** WDTÅäÖÃ³õÊ¼»¯ **************************************/
 138   1          WDTC   = 0x57;  // ÔÊÐíWDT¸´Î»£¬ÔÊÐíµôµç/¿ÕÏÐÄ£Ê½ÏÂÔËÐÐ£¬1024·ÖÆµ 5.93s
 139   1          WDTCCR = 0xFF;  // Ð´Èë00Ê±£¬½«¹Ø±ÕWDT¹¦ÄÜ£¨µ«²»¹Ø±ÕÄÚ²¿µÍÆµRC£©£¬
 140   1      
 141   1          /************************************* PWM³õÊ¼»¯ ****************************************/
 142   1          // ÆµÂÊÉèÖÃ·¶Î§£º489 - 2 000 000
 143   1      
 144   1          P2M1     = P2M1 & 0xF0 | 0x08;  // P22ÉèÖÃÎªÍÆÍìÊä³ö
 145   1          PWM0_MAP = 0x22;                // PWM0Í¨µÀÓ³ÉäP22¿Ú
 146   1          PWM0C    = 0x01;                // PWM0¸ßÓÐÐ§£¬PWM01¸ßÓÐÐ§£¬Ê±ÖÓ8·ÖÆµ
 147   1          PWM0PH   = 0x03;                // ÖÜÆÚ¸ß4Î»ÉèÖÃÎª0x03
 148   1          PWM0PL   = 0xFF;                // ÖÜÆÚµÍ8Î»ÉèÖÃÎª0xFF
 149   1          PWM0DH   = 0x01;                // PWM0¸ß4Î»Õ¼¿Õ±È0x01
 150   1          PWM0DL   = 0x55;                // PWM0µÍ8Î»Õ¼¿Õ±È0x55
 151   1          PWM0EN   = 0x0B;                // Ê¹ÄÜPWM0£¬¹¤×÷ÓÚ¶ÀÁ¢Ä£Ê½ PWM0Êä³ö PWM01¹Ø±Õ 0000 1011
 152   1      
 153   1          /************************************* Ö¸¶¨²¨ÐÎ ****************************************/
 154   1          P0M0 = P0M0 & 0x0F | 0x80;  //      P01ÉèÖÃÎªÍÆÍêÊä³ö
 155   1      
 156   1          /************************************* ¸ø¸÷Ïî²ÎÊýÉèÖÃ³õÖµ ****************************************/
 157   1          // ¶ÁÈ¡FlashÖÐµÄ¸÷Í¨µÀµçÑ¹ÏµÊý
 158   1          Flash_ReadArr(VolCoeFlashAddress, 16, VolCoeStore);
 159   1      
 160   1          for (i = 0; i < 4; i++) {
 161   2              memcpy(Vol_b.stByte.u8Byte, &VolCoeStore[i * 4], 4);
 162   2              VolCoe[i] = Vol_b.all;
 163   2          }
 164   1      
 165   1          // ´®¿Ú³¬Ê±ÅÐ¶Ï
 166   1          soft_timer_list_reset();
 167   1          add_timer(&usart1_timer, usart1_timeover_proc, 50);  // 50MS
 168   1          start_timer(&usart1_timer);
 169   1      
 170   1      
 171   1          // Çå¿Õ´®¿Ú½ÓÊÕ»º´æ
 172   1          memcpy(Uart1_rec.guc_Uartbuf_a, 0, 20);
 173   1      
 174   1      //    Uart1.FlagByte |= 0x01;  //´®¿Ú¿ÕÏÐ
 175   1      //    memcpy(Uart1.Data, 0, UART1BUFLEN);
 176   1      }
 177          
 178          /***************************************************************************************
C51 COMPILER V9.60.7.0   MAIN                                                              07/24/2023 16:59:30 PAGE 4   

 179           * @ËµÃ÷        ³õÊ¼»¯¹Ü½ÅÎªÍÆÍìÊä³ö
 180           * @²ÎÊý        IOPPx £ºÄÄÒ»×éIO
 181           *      @²ÎÊý   IOPPXx£ºÄ³Ò»¸öµÄÄÄÒ»¸öIO
 182           * @·µ»ØÖµ ÎÞ
 183           * @×¢            ÎÞ
 184           ***************************************************************************************/
 185          
 186          void IOInitPushpull(unsigned char IOPPx, unsigned char IOPPXx)
 187          {
 188   1      // ³õÊ¼»¯¹Ü½Å
 189   1          switch (IOPPx)
 190   1          {
 191   2              // P2
 192   2          case 0x02:
 193   2              switch (IOPPXx / 2)
 194   2              {
 195   3                  // P20 P21
 196   3              case 0:
 197   3                  (IOPPXx % 2) ? ( P2M0 = P2M0 & 0x0F | 0x80):(P2M0 = P2M0 & 0xF0 | 0x08);
 198   3                  break;
 199   3      
 200   3                  // P23 P22
 201   3              case 1:
 202   3                  (IOPPXx % 2) ? ( P2M1 = P2M1 & 0x0F | 0x80):(P2M1 = P2M1 & 0xF0 | 0x08);
 203   3                  break;
 204   3      
 205   3                  // P25 P24
 206   3              case 2:
 207   3                  (IOPPXx % 2) ? ( P2M2 = P2M2 & 0x0F | 0x80):(P2M2 = P2M2 & 0xF0 | 0x08);
 208   3                  break;
 209   3      
 210   3              case 3:
 211   3                  (IOPPXx % 2) ? ( P2M3 = P2M3 & 0x0F | 0x80):(P2M3 = P2M3 & 0xF0 | 0x08);
 212   3                  break;
 213   3      
 214   3              default:
 215   3                  break;
 216   3              }
 217   2              break;
 218   2      
 219   2              //P0
 220   2          case 0x00:
 221   2              switch (IOPPXx / 2)
 222   2              {
 223   3                  // P00 P01
 224   3              case 0:
 225   3                  (IOPPXx % 2) ? ( P0M0 = P0M0 & 0x0F | 0x80):(P0M0 = P0M0 & 0xF0 | 0x08);
 226   3                  break;
 227   3      
 228   3                  // P03 P02
 229   3              case 1:
 230   3                  (IOPPXx % 2) ? ( P0M1 = P0M1 & 0x0F | 0x80):(P0M1 = P0M1 & 0xF0 | 0x08);
 231   3                  break;
 232   3      
 233   3                  // P05 P04
 234   3              case 2:
 235   3                  (IOPPXx % 2) ? ( P0M2 = P0M2 & 0x0F | 0x80):(P0M2 = P0M2 & 0xF0 | 0x08);
 236   3                  break;
 237   3      
 238   3              case 3:
 239   3                  (IOPPXx % 2) ? ( P0M3 = P0M3 & 0x0F | 0x80):(P0M3 = P0M3 & 0xF0 | 0x08);
 240   3                  break;
C51 COMPILER V9.60.7.0   MAIN                                                              07/24/2023 16:59:30 PAGE 5   

 241   3      
 242   3              default:
 243   3                  break;
 244   3              }
 245   2              break;
 246   2      
 247   2          default:
 248   2              break;
 249   2          }
 250   1      }
 251          
 252          /***************************************************************************************
 253           * @ËµÃ÷        ADCÖÐ¶Ï·þÎñº¯Êý
 254           *      @²ÎÊý     ÎÞ
 255           * @·µ»ØÖµ ÎÞ
 256           * @×¢            ÎÞ
 257           ***************************************************************************************/
 258          void ADC_Rpt() interrupt ADC_VECTOR
 259          {
 260   1          // ¶ÁÈ¡ÊýÖµ
 261   1          ADCC0 &= ~0x20;  // Çå³ýADCÖÐ¶Ï±êÖ¾Î»
 262   1      
 263   1          gui_AdcValue_a[guc_Channel_Count] = ADCR;  // »ñÈ¡ADCÊý¾Ý
 264   1      
 265   1          guc_Channel_Count++;
 266   1          if (guc_Channel_Count == 4) {
 267   2              guc_Count++;
 268   2              guc_Channel_Count = 0;
 269   2              if (guc_Count == 64) {
 270   3                  guc_Count = 0;
 271   3              }
 272   2          }
 273   1      
 274   1          // ÇÐ»»Í¨µÀ
 275   1          ADCC1 = (ADCC1 & (~0x07)) | (guc_AdcChannel_a[guc_Channel_Count]);  // Ñ¡ÔñÍâ²¿Í¨µÀ
 276   1      //    Delay_2us(10);                                                      // ÇÐ»»Í¨µÀºó½¨ÒéÑÓÊ±20us
 277   1      }
 278          
 279          /***************************************************************************************
 280           * @ËµÃ÷        T0ÖÐ¶Ï·þÎñº¯Êý
 281           *      @²ÎÊý     ÎÞ
 282           * @·µ»ØÖµ ÎÞ
 283           * @×¢            ÎÞ
 284           ***************************************************************************************/
 285          void TIMER0_Rpt(void) interrupt TIMER0_VECTOR  // 1ms
 286          {
 287   1          // ´®¿Ú³¬Ê±ÅÐ¶Ï
 288   1          timer_periodic_refresh();
 289   1      
 290   1          // Æô¶¯×ª»»
 291   1          ADCC0 |= 0x40;  // Æô¶¯ÏÂÒ»´Î×ª»»
 292   1      
 293   1          // PWM¹¤×÷ÖÜÆÚÉèÖÃ
 294   1          PWMOut_count++;
 295   1          if (PWMOut_count > PWMWorkTime) {
 296   2              PWM0EN &= ~0x01;  // ¹Ø±ÕPWMÄ£¿é
 297   2          }
 298   1      
 299   1          if (PWMOut_count >= PWMOutCycle) {
 300   2              PWMOut_count = 0;
 301   2              PWM0EN |= 0x01;  // ´ò¿ªPWMÄ£¿é
 302   2          }
C51 COMPILER V9.60.7.0   MAIN                                                              07/24/2023 16:59:30 PAGE 6   

 303   1      }
 304          
 305          /**
 306           * @ËµÃ÷        ÑÓÊ±º¯Êý
 307           * @²ÎÊý        fui_i : ÑÓÊ±Ê±¼ä
 308           * @·µ»ØÖµ ÎÞ
 309           * @×¢  Fcpu = 16MHz,fui_i = 1Ê±,ÑÓÊ±Ê±¼äÔ¼Îª2us
 310           */
 311          void Delay_2us(unsigned int fui_i)
 312          {
 313   1          while (fui_i--)
 314   1              ;
 315   1      }
 316          
 317          /***************************************************************************************
 318           * @ËµÃ÷        UART1ÖÐ¶Ï·þÎñº¯Êý
 319           *      @²ÎÊý     ÎÞ
 320           * @·µ»ØÖµ ÎÞ
 321           * @×¢            ÎÞ
 322           ***************************************************************************************/
 323          void UART1_Rpt(void) interrupt UART1_VECTOR
 324          {
 325   1          static unsigned char UartsdfCnt = 0, UsartRecflg = 0, temp = 0;
 326   1      
 327   1          /* ´®¿Ú½ÓÊÜÖÐ¶Ï */
 328   1          if (SCON & 0x01)  // ÅÐ¶Ï½ÓÊÕÖÐ¶Ï±êÖ¾Î»
 329   1          {
 330   2              reload_timer(&usart1_timer, 50);  // ÈôÓÐ×Ö·ûÊÕµ½£¬×°³õÖµ²¢Æô¶¯¶¨Ê±Æ÷£¬Èô×Ö½Ú³¬Ê±£¬Ôò»á×Ô¶¯µ÷ÓÃ¶¨Ê
             -±Æ÷³¬Ê±º¯Êý,³¬Ê±ÉèÎª50ms
 331   2              start_timer(&usart1_timer);
 332   2      
 333   2              if (UsartRecflg)  // ¿ªÊ¼½ÓÊÕÊý¾Ý
 334   2              {
 335   3                  Uart1_rec.guc_Uartbuf_temp[Uart1_rec.guc_Uartcnt++] = SBUF;  // ×ª´æ8Î»´®¿Ú½ÓÊÕÊý¾Ý
 336   3              }
 337   2      
 338   2              // Ö¡Í·
 339   2              if (SBUF == 0xff)  // ÅÐ¶ÏÓÐÃ»ÓÐ¿ÉÄÜÊÇÖ¡Í·
 340   2              {
 341   3                  UartsdfCnt++;
 342   3              }
 343   2              else 
 344   2              {
 345   3                  UartsdfCnt = 0;
 346   3              }
 347   2      
 348   2              if (UartsdfCnt == 2)  // ½ÓÊÕµ½Ö¡Í·(2¸ö0xff),¿ªÊ¼½ÓÊÕÊý¾Ý
 349   2              {
 350   3                  UsartRecflg = 1;
 351   3      
 352   3                  Uart1_rec.guc_Uartcnt = 0;  // ¿ªÊ¼½ÓÊÕÊý¾Ý£¬ÇåÁã¼ÆÊý
 353   3      
 354   3                  // Çå¿Õ´®¿Ú½ÓÊÕ»º´æ
 355   3                  memcpy(Uart1_rec.guc_Uartbuf_temp, 0, 20);
 356   3              }
 357   2      
 358   2              // ½ÓÊÕµÄÊý¾ÝÌ«¶à
 359   2              if (Uart1_rec.guc_Uartcnt >= 20) {
 360   3                  Uart1_rec.guc_Uartflag = 1;
 361   3                  memcpy(Uart1_rec.guc_Uartbuf_a, 0, 20);
 362   3                  memcpy(Uart1_rec.guc_Uartbuf_a, Uart1_rec.guc_Uartbuf_temp,Uart1_rec.guc_Uartcnt);
 363   3                  Uart1_rec.guc_Uartcnt  = 0;
C51 COMPILER V9.60.7.0   MAIN                                                              07/24/2023 16:59:30 PAGE 7   

 364   3              }
 365   2      
 366   2              SCON &= ~0x01;  // Çå³ý½ÓÊÕÖÐ¶Ï±êÖ¾Î»
 367   2          }
 368   1      
 369   1          /* ´®¿Ú·¢ËÍÖÐ¶Ï */
 370   1          if (SCON & 0x02)  // ÅÐ¶Ï·¢ËÍÖÐ¶Ï±êÖ¾Î»
 371   1          {
 372   2              if (ringBuff.Lenght) //»º´æÇøÓÐÊý¾Ý 
 373   2              {
 374   3                  if (Read_RingBuff(&temp,&ringBuff))
 375   3                  {
 376   4                      SBUF = temp;
 377   4                  }
 378   3              }
 379   2              else //»º´æÇøÃ»ÓÐÊý¾Ý
 380   2              {
 381   3                  ringBuff.FlagByte |= 0x01;    //´®¿Ú¿ÕÏÐ 
 382   3              }
 383   2      
 384   2              SCON &= ~0x02;  // Çå³ý·¢ËÍÖÐ¶Ï±êÖ¾Î»
 385   2          }
 386   1      }
 387          
 388          /***************************************************************************************
 389           * @ËµÃ÷        ´®¿Ú1¶¨Ê±Æ÷×Ö½Ú³¬Ê±´¦Àí
 390           *      @²ÎÊý   ÎÞ
 391           * @·µ»ØÖµ ÎÞ
 392           * @×¢          ÎÞ
 393           ***************************************************************************************/
 394          void usart1_timeover_proc(void)
 395          {
 396   1      //    SCON &= ~0x10;  // Ê§ÄÜUART1½ÓÊÕ
 397   1          memcpy(Uart1_rec.guc_Uartbuf_a, 0, 20);
 398   1          memcpy(Uart1_rec.guc_Uartbuf_a, Uart1_rec.guc_Uartbuf_temp,Uart1_rec.guc_Uartcnt); //±£´æ½ÓÊÕµ½µÄÊý¾Ý
 399   1      
 400   1          Uart1_rec.guc_Uartflag = 1;
 401   1          Uart1_rec.guc_Uartcnt  = 0;
 402   1      }
 403          
 404          /**
 405           * @ËµÃ÷        Ð´ÈëÒ»¸ö×Ö½ÚÊý¾Ýµ½FlashÀïÃæ
 406           * @²ÎÊý        fui_Address £ºFLASHµØÖ·
 407           *      @²ÎÊý   fucp_SaveData£ºÐ´ÈëµÄÊý¾Ý´æ·ÅÇøÓòµÄÊ×µØÖ·
 408           * @·µ»ØÖµ ÎÞ
 409           * @×¢          Ð´Ö®Ç°±ØÐëÏÈ¶Ô²Ù×÷µÄÉÈÇø½øÐÐ²Á³ý
 410           */
 411          #pragma disable  // È·±£µ÷ÕûÊ±²»»á½øÖÐ¶Ïµ¼ÖÂµ÷ÕûÊ§°Ü
 412          void FLASH_WriteData(unsigned char fuc_SaveData, unsigned int fui_Address)
 413          {
 414   1          IAP_DATA = fuc_SaveData;
 415   1          IAP_CMD  = 0xF00F;  // Flash½âËø
 416   1          IAP_ADDR = fui_Address;
 417   1          IAP_CMD  = 0xB44B;  // ×Ö½Ú±à³Ì
 418   1          IAP_CMD  = 0xE11E;  // ´¥·¢Ò»´Î²Ù×÷
 419   1      }
 420          
 421          /**
 422           * @ËµÃ÷        Ð´ÈëÈÎÒâ³¤¶ÈµÄÊý¾Ýµ½FLASHÀïÃæ
 423           * @²ÎÊý        fui_Address £ºFLASHÆðÊ¼µØÖ·
 424           *      @²ÎÊý   fuc_Length £º Ð´ÈëÊý¾Ý³¤¶È
 425           *                          È¡Öµ·¶Î§£º0x00-0xFF
C51 COMPILER V9.60.7.0   MAIN                                                              07/24/2023 16:59:30 PAGE 8   

 426           *      @²ÎÊý    *fucp_SaveArr£ºÐ´ÈëµÄÊý¾Ý´æ·ÅÇøÓòµÄÊ×µØÖ·
 427           * @·µ»ØÖµ ÎÞ
 428           * @×¢            Ð´Ö®Ç°±ØÐëÏÈ¶Ô²Ù×÷µÄÉÈÇø½øÐÐ²Á³ý
 429           */
 430          #pragma disable  // È·±£µ÷ÕûÊ±²»»á½øÖÐ¶Ïµ¼ÖÂµ÷ÕûÊ§°Ü
 431          void Flash_WriteArr(unsigned int fui_Address, unsigned char fuc_Length, unsigned char* fucp_SaveArr)
 432          {
 433   1          unsigned char fui_i = 0;
 434   1          for (fui_i = 0; fui_i < fuc_Length; fui_i++) {
 435   2              FLASH_WriteData(*(fucp_SaveArr++), fui_Address++);
 436   2          }
 437   1      }
 438          
 439          /**
 440           * @ËµÃ÷        ´ÓFLASHÀïÃæ¶ÁÈ¡ÈÎÒâ³¤¶ÈµÄÊý¾Ý
 441           * @²ÎÊý        fui_Address £ºFLASHÆðÊ¼µØÖ·
 442           * @²ÎÊý          fuc_Length £º¶ÁÈ¡Êý¾Ý³¤¶È
 443           *                          È¡Öµ·¶Î§£º0x00-0xFF
 444           * @²ÎÊý         *fucp_SaveArr£º¶ÁÈ¡Êý¾Ý´æ·ÅµÄÇøÓòÊ×µØÖ·
 445           * @·µ»ØÖµ ÎÞ
 446           * @×¢            ÎÞ
 447           */
 448          void Flash_ReadArr(unsigned int fui_Address, unsigned char fuc_Length, unsigned char* fucp_SaveArr)
 449          {
 450   1          while (fuc_Length--) *(fucp_SaveArr++) = *((unsigned char code*)(fui_Address++));  // ¶ÁÈ¡Êý¾Ý
 451   1      }
 452          
 453          /**
 454           * @ËµÃ÷        ÉÈÇø²Á³ý£¬Ô¼ÏûºÄ5msµÄÊ±¼ä
 455           * @²ÎÊý        fui_Address £º±»²Á³ýµÄÉÈÇøÄÚµÄÈÎÒâÒ»¸öµØÖ·
 456           * @·µ»ØÖµ ÎÞ
 457           * @×¢            Ö»Òª²Ù×÷ÉÈÇøÀïÃæµÄÈÎÒâÒ»¸öµØÖ·£¬¾Í¿ÉÒÔ²Á³ý´ËÉÈÇø
 458           */
 459          #pragma disable  // È·±£µ÷ÕûÊ±²»»á½øÖÐ¶Ïµ¼ÖÂµ÷ÕûÊ§°Ü
 460          void Flash_EraseBlock(unsigned int fui_Address)
 461          {
 462   1          IAP_CMD  = 0xF00F;       // Flash½âËø
 463   1          IAP_ADDR = fui_Address;  // Ð´Èë²Á³ýµØÖ·
 464   1          IAP_CMD  = 0xD22D;       // Ñ¡Ôñ²Ù×÷·½Ê½£¬ ÉÈÇø²Á³ý
 465   1          IAP_CMD  = 0xE11E;       // ´¥·¢ºóIAP_ADDRL&IAP_ADDRHÖ¸Ïò0xFF£¬Í¬Ê±×Ô¶¯Ëø¶¨
 466   1      }
 467          
 468          /***************************************************************************************
 469           * @ËµÃ÷        T1ÖÐ¶Ï·þÎñº¯Êý
 470           *      @²ÎÊý     ÎÞ
 471           * @·µ»ØÖµ ÎÞ
 472           * @×¢            ÎÞ
 473           ***************************************************************************************/
 474          void TIMER1_Rpt(void) interrupt TIMER1_VECTOR  // 25msÖÐ¶Ï
 475          {
 476   1          static unsigned int count = 0;
 477   1          count++;
 478   1          if (count >= 4) 
 479   1          {
 480   2              count = 0;
 481   2              // Êä³öÖ¸¶¨²¨ÐÎ
 482   2              switch (SpecifywaveIOflag) 
 483   2              {
 484   3                  // P01
 485   3                  case 0:P0_1 = SpecifywaveformOut[SpecifywaveCount];break;
 486   3      
 487   3                  // P05
C51 COMPILER V9.60.7.0   MAIN                                                              07/24/2023 16:59:30 PAGE 9   

 488   3                  case 1:P0_5 = SpecifywaveformOut[SpecifywaveCount];break;
 489   3      
 490   3                  // P07
 491   3                  case 2:P0_7 = SpecifywaveformOut[SpecifywaveCount];break;
 492   3      
 493   3                  default:break;
 494   3              }
 495   2              SpecifywaveCount++;
 496   2              if (SpecifywaveCount > 14) SpecifywaveCount = 0;
 497   2          }
 498   1      }
 499          
 500          /***************************************************************************************
 501           * @ËµÃ÷        Ö¸ÁîÂÖÑ¯º¯Êý
 502           * @²ÎÊý    ÎÞ
 503           * @·µ»ØÖµ  ÎÞ
 504           * @×¢      ÎÞ
 505           ***************************************************************************************/
 506          void poll_task(u8 cmd)
 507          {
 508   1          int cmd_index = 0;
 509   1      
 510   1          for (cmd_index = 0; cmd_index < 5; cmd_index++)
 511   1          {
 512   2              if (callback_list[cmd_index].CMD == cmd)
 513   2              {
 514   3                  callback_list[cmd_index].callback_func(Uart1_rec.guc_Uartbuf_a);
 515   3              }
 516   2          }
 517   1      
 518   1      }
 519          
 520          /***************************************************************************************
 521           * @ËµÃ÷        ¹¦ÄÜ£º²éÑ¯Í¨µÀµçÑ¹ µÄ»Øµ÷º¯Êý
 522           * @²ÎÊý    ÎÞ
 523           * @·µ»ØÖµ  ÎÞ
 524           * @×¢      ÎÞ
 525           ***************************************************************************************/
 526          /*********************** 1 ²éÑ¯Í¨µÀµçÑ¹ ***********************/
 527          // ¹Ü½Å: P00 P02 P04 P06
 528          // »º´æÇøÊý¾Ý£º0x01£¬Í¨µÀÑ¡Ôñ£¨1¸ö×Ö½Ú£©
 529          void callback_QueryVoltage(unsigned char *myStr)
 530          {
 531   1          u8 ANx = 0;
 532   1          float UARTprintVolCoe = 0;
 533   1          if (myStr[1] == 0x00 ||
 534   1              myStr[1] == 0x02 ||
 535   1              myStr[1] == 0x04 ||
 536   1              myStr[1] == 0x06)
 537   1          {
 538   2              ANx = (int)myStr[1]/2;
 539   2              UARTprintVolCoe = (float)(gui_AdcValue_a[ANx] / 4096.0) * VDD * VolCoe[ANx];
 540   2              sprintf(guc_Uartbuf_p,"AN%d = %f\r\n", (int)myStr[1],UARTprintVolCoe);
 541   2          }
 542   1          else
 543   1          {
 544   2              sprintf(guc_Uartbuf_p,"¸ÃÍ¨µÀ²»´æÔÚ£¡\r\n");
 545   2          }
 546   1          
 547   1          
 548   1      //    sprintf(guc_Uartbuf_p,"¹¦ÄÜ1\r\n");
 549   1      }
C51 COMPILER V9.60.7.0   MAIN                                                              07/24/2023 16:59:30 PAGE 10  

 550          
 551          
 552          /***************************************************************************************
 553           * @ËµÃ÷        ¹¦ÄÜ£ºÐÞ¸ÄÖ¸¶¨Í¨µÀµçÑ¹²ÎÊý µÄ»Øµ÷º¯Êý
 554           * @²ÎÊý    ÎÞ
 555           * @·µ»ØÖµ  ÎÞ
 556           * @×¢      ÎÞ
 557           ***************************************************************************************/
 558          /*********************** 2 ÐÞ¸ÄÖ¸¶¨Í¨µÀµçÑ¹²ÎÊý ***********************/
 559          // ¹Ü½Å: P00 P02 P04 P06
 560          // »º´æÇøÊý¾Ý£º0x02£¬Í¨µÀÑ¡Ôñ£¨1¸ö×Ö½Ú£©£¬µçÑ¹ÏµÊý£¨4¸ö×Ö½Ú£¬float£©
 561          void callback_ModifyVoltageParameters(unsigned char *myStr)
 562          {
 563   1          if (myStr[1] == 0x00 || myStr[1] == 0x02 || myStr[1] == 0x04 || myStr[1] == 0x06)
 564   1          {
 565   2              memcpy(Vol_a.stByte.u8Byte, &myStr[2], 4);
 566   2              VolCoe[(int)myStr[1] / 2] = Vol_a.all;
 567   2      
 568   2              for (i = 0; i < 4; i++)
 569   2              {
 570   3                  Vol_b.all = VolCoe[i];
 571   3                  memcpy(&VolCoeStore[i * 4], Vol_b.stByte.u8Byte, 4);
 572   3              }
 573   2              Flash_EraseBlock(VolCoeFlashAddress);                 // ²Á³ýµØÖ·0x3B00ËùÔÚÉÈÇø
 574   2              Flash_WriteArr(VolCoeFlashAddress, 16, VolCoeStore);  // ÔÚµØÖ·0x3B00Ð´ÈëÊý¾Ý
 575   2              sprintf(guc_Uartbuf_p,"ok!\r\nVolCoe: %f - %f - %f - %f\r\n", VolCoe[0], VolCoe[1], VolCoe[2], Vol
             -Coe[3]);
 576   2          }
 577   1          else
 578   1          {
 579   2              sprintf(guc_Uartbuf_p,"ÉèÖÃ´íÎó!\r\n");
 580   2          }
 581   1          
 582   1      //    sprintf(guc_Uartbuf_p,"¹¦ÄÜ2\r\n");
 583   1      }
 584          
 585          /***************************************************************************************
 586           * @ËµÃ÷        ¹¦ÄÜ£ºÖ¸¶¨PWM²¨ÊµÏÖ¹Ü½Å£¬ÆµÂÊºÍÕ¼¿Õ±È µÄ»Øµ÷º¯Êý
 587           * @²ÎÊý    ÎÞ
 588           * @·µ»ØÖµ  ÎÞ
 589           * @×¢      ÎÞ
 590           ***************************************************************************************/
 591          /*********************** 3 Ö¸¶¨PWM²¨ÊµÏÖ¹Ü½Å£¬ÆµÂÊºÍÕ¼¿Õ±È ***********************/
 592          // ¹Ü½Å: P20 P22 P23 P24 P25 P26 P27    ÆµÂÊ£º489 - 2M   Õ¼¿Õ±È£º0 - 100
 593          // »º´æÇøÊý¾Ý£º0x03£¬¹Ü½ÅÑ¡Ôñ£¨1¸ö×Ö½Ú£©£¬ÆµÂÊ£¨3¸ö×Ö½Ú£©£¬Õ¼¿Õ±È£¨1¸ö×Ö½Ú£©
 594          void callback_ModifyPWMParameter(unsigned char *myStr)
 595          {
 596   1          strChar           IOPP;
 597   1          unsigned long int PWMFrequency = 0;
 598   1          unsigned int      PWMCycle = 0, PWMDutycycle = 0;  // PWMCycle - ´æ·ÅPWM²¨µÄÖÜÆÚ  PWMDutycycle - ´æ·ÅP
             -WMÕ¼¿Õ±ÈµÄ¾ßÌåÊýÖµ
 599   1      
 600   1          // ÅÐ¶Ï¹Ü½ÅÑ¡ÔñÊý¾ÝÊÇ·ñ·ûºÏÌõ¼þ
 601   1          IOPP.byte = myStr[1];
 602   1          
 603   1          if ((myStr[1] & 0xc8) != 0x00) 
 604   1          {
 605   2              sprintf(guc_Uartbuf_p,"Ö¸¶¨PWMÊä³ö¹Ü½Å´íÎó!\r\n");
 606   2              return ;
 607   2          }
 608   1      
 609   1      
C51 COMPILER V9.60.7.0   MAIN                                                              07/24/2023 16:59:30 PAGE 11  

 610   1          if (IOPP.half.low != 0x02) 
 611   1          {
 612   2              sprintf(guc_Uartbuf_p,"Ö¸¶¨PWMÊä³ö¹Ü½Å´íÎó!\r\n");
 613   2              return ;
 614   2          }
 615   1      
 616   1          if (IOPP.half.high == 0x01) 
 617   1          {
 618   2              sprintf(guc_Uartbuf_p,"Ö¸¶¨PWMÊä³ö¹Ü½Å´íÎó!\r\n");
 619   2              return ;
 620   2          }
 621   1        
 622   1      
 623   1          // ÆµÂÊÊÇ·ñ³¬¹ýÏÞÖÆ
 624   1          PWMFrequency = (myStr[2] * 65536 + myStr[3] * 256 + myStr[4]);
 625   1          
 626   1          if (PWMFrequency < 489)
 627   1          {
 628   2              sprintf(guc_Uartbuf_p,"PWM ÆµÂÊÌ«Ð¡\r\n");
 629   2              return ;
 630   2          }
 631   1          else if (PWMFrequency > 2000000)
 632   1          {
 633   2              sprintf(guc_Uartbuf_p,"PWM ÆµÂÊÌ«´ó\r\n");
 634   2              return ;
 635   2          }
 636   1      
 637   1          // Õ¼¿Õ±ÈÊÇ·ñ³¬¹ýÏÞÖÆ
 638   1          if ((int)myStr[5] > 100)
 639   1          {
 640   2              sprintf(guc_Uartbuf_p,"PWM Õ¼¿Õ±ÈÌ«´ó\r\n");
 641   2              return ;
 642   2          }
 643   1      
 644   1          // ÅäÖÃIOÎªÍÆÍêÊä³ö
 645   1          IOInitPushpull(IOPP.half.low, IOPP.half.high);
 646   1      
 647   1          // PWMÊä³ö¹Ü½ÅÖØÓ³Éä
 648   1          PWM0_MAP = myStr[1];
 649   1      
 650   1          // ÆµÂÊÉèÖÃ£¨ÖÜÆÚ£©
 651   1          PWMCycle = 2000000 / PWMFrequency;
 652   1          PWM0PH   = (PWMCycle >> 8) & 0xff;
 653   1          PWM0PL   = PWMCycle & 0xff;
 654   1      
 655   1          // Õ¼¿Õ±ÈÉèÖÃ
 656   1          PWMDutycycle = (unsigned int)(PWMCycle * (float)myStr[5] / 100.0);
 657   1          PWM0DH = (PWMDutycycle >> 8) & 0x0f;
 658   1          PWM0DL = (PWMDutycycle)&0xff;
 659   1      
 660   1          sprintf(guc_Uartbuf_p,"PWM²¨ÉèÖÃ³É¹¦,IO:P%d%d, ÆµÂÊ:%ld, Õ¼¿Õ±È:%u%%\r\n",(int)IOPP.half.low, (int)IOP
             -P.half.high, (long int)PWMFrequency, (unsigned int)myStr[5]);
 661   1              
 662   1      //    sprintf(guc_Uartbuf_p,"¹¦ÄÜ3\r\n");
 663   1      }
 664          
 665          /***************************************************************************************
 666           * @ËµÃ÷        ¹¦ÄÜ£ºÖ¸¶¨PWMÊä³öÖÜÆÚºÍ¹¤×÷Ê±¼ä µÄ»Øµ÷º¯Êý
 667           * @²ÎÊý    ÎÞ
 668           * @·µ»ØÖµ  ÎÞ
 669           * @×¢      ÎÞ
 670           ***************************************************************************************/
C51 COMPILER V9.60.7.0   MAIN                                                              07/24/2023 16:59:30 PAGE 12  

 671          /*********************** 4 Ö¸¶¨PWMÊä³öÖÜÆÚºÍ¹¤×÷Ê±¼ä ***********************/
 672          // »º´æÇøÊý¾Ý£º0x04£¬²úÉúÖÜÆÚ£¨2¸ö×Ö½Ú£©£¬¹¤×÷Ê±¼ä£¨2¸ö×Ö½Ú£©
 673          void callback_PWMOperatingParameters(unsigned char *myStr)
 674          {
 675   1          PWMOutCycle = myStr[1] * 256 + myStr[2];
 676   1          PWMWorkTime = myStr[3] * 256 + myStr[4];
 677   1          sprintf(guc_Uartbuf_p,"PWM¹¤×÷ÖÜÆÚ = %dms   ¹¤×÷Ê±¼ä = %dms\r\n", PWMOutCycle, PWMWorkTime);
 678   1          
 679   1      //    sprintf(guc_Uartbuf_p,"¹¦ÄÜ4\r\n");
 680   1      }
 681          
 682          /***************************************************************************************
 683           * @ËµÃ÷        ¹¦ÄÜ£ºÊä³öÖ¸¶¨²¨ÐÎ µÄ»Øµ÷º¯Êý
 684           * @²ÎÊý    ÎÞ
 685           * @·µ»ØÖµ  ÎÞ
 686           * @×¢      ÎÞ
 687           ***************************************************************************************/
 688          /*********************** 5 Êä³öÖ¸¶¨²¨ÐÎ P01 P05 P07 ***********************/
 689          // ¹Ü½Å: P01 P05 P07
 690          // »º´æÇøÊý¾Ý£º0x05£¬¹Ü½ÅÑ¡Ôñ£¨1¸ö×Ö½Ú£©  //fixme ÎªÊ²Ã´Ê¹ÓÃPWMÊµÏÖÖ¸¶¨²¨ÐÎ£¿100msµÄÖÜÆÚÈçºÎÊµÏÖµÄ£¿
 691          void callback_SpecifyWaveform(unsigned char *myStr)
 692          {
 693   1          strChar  IOPP;
 694   1          
 695   1          IOPP.byte = Uart1_rec.guc_Uartbuf_a[1];
 696   1      
 697   1          if (myStr[1] == 0x01 ||
 698   1              myStr[1] == 0x05 ||
 699   1              myStr[1] == 0x07)
 700   1          {
 701   2              // ÅäÖÃIOÎªÍÆÍêÊä³ö P01 P05 P07
 702   2              IOInitPushpull(IOPP.half.low, IOPP.half.high);
 703   2              SpecifywaveCount = 0;
 704   2      
 705   2              sprintf(guc_Uartbuf_p,"ÉèÖÃÖ¸¶¨²¨ÐÎÊä³ö¹Ü½ÅÎª:P%d%d\r\n", (int)IOPP.half.low, (int)IOPP.half.high)
             -;
 706   2          }
 707   1          else
 708   1          {
 709   2              sprintf(guc_Uartbuf_p,"Ö¸¶¨²¨ÐÎÊä³ö¹Ü½Å´íÎó!\r\n");
 710   2          }
 711   1      
 712   1      //    sprintf(guc_Uartbuf_p,"¹¦ÄÜ5\r\n");
 713   1      }
 714          
 715          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3205    ----
   CONSTANT SIZE    =    301    ----
   XDATA SIZE       =    281      39
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
